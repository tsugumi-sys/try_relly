## 概要

個人の勉強用にRellyのコードをみながら実装していくリポジトリです。

## 情報

目次情報:

```
第1章：RDBMSを作ろう
作りながら内部のしくみを知る…… KOBA789
第2章：ディスクマネージャの実装
データの塊をディスクに書く・読む…… KOBA789
第3章：バッファプールマネージャの実装
データの塊をメモリにキャッシュする…… KOBA789
第4章：B+Treeの観察
巨大なデータを高速に検索する…… KOBA789
第5章：テーブルの実装
B+Treeにテーブルを格納する…… KOBA789
第6章：セカンダリインデックスの実装
プライマリキー以外でも高速に検索する…… KOBA789
```

## 詰まったとこ

## 勉強

### ヒープとヒープファイル

ヒープは木構造の１つ。親が常に子より大きくなるか等しくなるように設計するもの。ファイルの分割状態を管理するのに適したデータ構造と言えそう。

ヒープファイルとは、ページという大きさにファイルを分割し順序関係なくデータをページに書き込むことができるファイル。

単一のファイル内に、データブロックをいくつも作成するイメージ。

ヒープファイルのヒープってどんな意味だろう。

### std::cell::Cell

データ格納方法の一つ。所有権なしでデータを読み書きできる。安全な環境下においては、簡単にデータの読み書きができる。

### Disk Manager

- ファイル操作（読み取り書き込み）のAPIを提供する。
- ページサイズごとにデータを格納・メモリに展開して、書き込み・読み込みする。

### Bufferpool Manager

- ページごとにバッファを割り当てて、メモリ上にデータを展開する。
- メモリ上にデータを読み込ませたり、ディスクに書き込ませたりする。
- 複数のバッファを用意してよりたくさんのデータを高速に読み書きできるようにする。

## Btree

効率的なデータ探索のためにバイナリツリーを用いる。
バイナリツリーはいくつかの場所で利用されている。

- ページIDに基づいてバイナリツリーを構築する。目的のPageを高速に発見する。
- Pageの中身（レコード）に基づいてバイナリツリーを構築する。Page内部を高速に探索する。

探索だけでなく、データ挿入時のページ分割・ツリー構造の修正を行う必要がある。

### Branch

- PageIdをバイナリーツリー構造で保存するためのモジュール。ページが追加・削除された際に、木構造を操作するためのインターフェースを提供する。

### Leaf

- リーフノードを管理するためのモジュール。リーフノードへのデータ書き込みや、データ移動（新しくノードが追加された時に、それぞれ半分ずつデータを均等に配置する）のためのインターフェースを提供する。

## Memcmpable

length-prefixed encoding and decoding mechanism for sequences of bytes

つまり単一のブロック（Page）内部でバイトブロックのチャンクを作るためのもの。

具体的には、データ末尾にエスケープバイトを設置することで、分割箇所をわかるようにしている。 

## Executor (query.rs)

メタ情報を読み込んで、クエリを実行する（データ取得かな）モジュール。

クエリのコンディションに基づいて、Pageを１つずつ検索していく。

シーケンシャルスキャンの場合は、テーブルメタ情報を読み取って、１つづつ見ていくだけ。発見されたデータはバッファから読み込まれて、デコードされて変換される。

インデックススキャンの場合は、テーブルメタ情報とインデックステーブルメタ情報の両方を読み取ってテーブルを探索してく。

## What is `repr(C)`

https://doc.rust-lang.org/nomicon/other-reprs.html#alternative-representations

Rustで定義した構造体を外（外部呼び出し先）に渡す場合に必要。メモリ上のレイアウトがCで書いた場合と同じになるので、C言語を使っていれば外部アプリケーションでもデータを解釈できる。

## 参考

- 筆者のブログ：https://diary.hatenablog.jp/entry/2021/04/08/190000
